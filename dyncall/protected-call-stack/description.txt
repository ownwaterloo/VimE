如果使用dyncall作为动态调用， 就没有对callee签名的静态类型检查。
如果出错， 栈将直接被corrupted……

所以打算实验是否能在非caller的栈上调用函数，
即使损坏， 也是损坏另一个调用栈。
caller可能就有机会检测并报告错误。

转到另一个调用栈的手段么……
setjmp……
而且损坏了也没关系， 反正下次依然是setjmp

而开启一个新的调用栈么……
试试开启一个线程， 执行setjmp后就再也不执行代码，
随后仅仅作为备用调用栈……

这个试验并不是直接测试dyncall， 而仅仅是在另一个调用栈上执行代码。
所以并不真正涉及dyncall库。
被调用的函数也是静态的， 而非动态的。

todo

* 栈的扩张

如果成功， 可以在备用栈上执行代码。
那么， 当栈保留的页消耗完毕后， 会提交哪一个页？
感觉应该是备用栈的页， 而不是caller的页。

用递归函数去测试
